@startuml stream_parser
hide empty members
namespace pdfparser {
enum ignore_flag <<Enumeration>> {
	<<Const, Flag>>
	+{static} none            : uint8_t = 0
	+{static} null            : uint8_t = 1
	+{static} horizontal_tab  : uint8_t = 2
	+{static} line_feed       : uint8_t = 4
	+{static} form_feed       : uint8_t = 8
	+{static} carriage_return : uint8_t = 16
	+{static} space           : uint8_t = 32
	+{static} comment         : uint8_t = 64

	+{static} EOL
	 : uint8_t = line_feed | carriage_return
	+{static} any_whitespace_characters
	 : uint8_t = null | horizontal_tab | line_feed | form_feed | carriage_return | space | EOL
	+{static} any_whitespace_characters_except_EOL
	 : uint8_t = any_whitespace_characters & ~EOL
}
class stream_parser<InputStreamT> {
	-m_stream : InputStreamT

	+stream_parser(inout stream : InputStreamT&&)
	+stream_parser(InputStreamT&)        = delete
	+stream_parser(const InputStreamT&&) = delete
	+take_footer(inout object_accessor : object_pool<InputStreamT>&) : dictionary_object
	+seek_to_end()                                                   : void
	+eof()                                                           : bool
	+tell()                                                          : std::streamoff
	+seek(in byte_offset_from_beginning_of_file : std::streamoff)    : void
	+seek_forward_head_of_line()                                     : void
	+take_xref_table()                                               : xref_table
	+take_xref_entry(in object_number : object_t)                    : xref_entry
	+take_trailer(inout object_accessor : object_pool<InputStreamT>&)           : dictionary_object

	+take_object                    (inout object_accessor : object_pool<InputStreamT>&) : variant<any_direct_object_or_ref の型リスト>
	+take_object<...ObjectTypes>    (inout object_accessor : object_pool<InputStreamT>&  (ObjectTypes に stream_object がある場合のみ)) : variant<ObjectTypes...>
	+take_object<boolean_object>    () : boolean_object
	+take_object<integer_object>    () : integer_object
	+take_object<real_object>       () : real_object
	+take_object<string_object>     () : string_object
	+take_object<name_object>       () : name_object
	+take_object<array_object>      () : array_object
	+take_object<dictionary_object> () : dictionary_object
	+take_object<stream_object>     (inout object_accessor : object_pool<InputStreamT>&) : stream_object
	+take_object<null_object>       () : null_object
	+take_object<indirect_reference>() : indirect_reference

	+take_indirect_object(inout object_accessor : object_pool<InputStreamT>&, in object_info : const xref_inuse_entry&) : any_direct_object
	+take_token(in attempt_token : string_view) : bool
	+take_token()                               : optional<pdftoken>
	+attempt(in attempt_str : string_view)      : bool
	+ignore_if_present(in flags : ignore_flag)  : void
}
stream_parser ..> ignore_flag
stream_parser ..> xref_types
stream_parser ..> object_types
stream_parser <..> object_pool<InputStreamT>
stream_parser ..> parse_error
stream_parser ..> pdftoken

annotation xref_types <<(N, yellow) namespace>> {
	[[xref_types.class.pu]]
}
annotation object_types <<(N, yellow) namespace>> {
	[[object_types.class.pu]]
}
class object_pool<InputStreamT> {
	[[object_pool.class.pu]]
}
class parse_error {
	[[error_types.class.pu]]
}
struct pdftoken {
	[[pdftoken.class.pu]]
}
}
@enduml
