@startuml object_types
hide empty members
namespace pdfparser {
annotation null_constant <<(N, yellow) global unnamed namespace>> {
	<<Constexpr>>
	+null : null_object
}
}
namespace pdfparser::object_types {
annotation object_types <<(N, yellow) namespace>> {
	+any_direct_object
	 : typedef = variant<boolean_object, integer_object,
	                     real_object, string_object,
	                     name_object, array_object,
	                     dictionary_object, stream_object,
	                     null_object>
	+any_direct_object_or_ref
	 : typedef = variant<boolean_object, integer_object,
	                     real_object, string_object,
	                     name_object, array_object,
	                     dictionary_object, stream_object,
	                     null_object, indirect_reference>
	+non_null_direct_object_or_ref
	 : typedef = variant<boolean_object, integer_object,
	                     real_object, string_object,
	                     name_object, array_object,
	                     dictionary_object, stream_object,
	                     indirect_reference>
	+boolean_object    : typedef = bool
	+integer_object    : typedef = int
	+real_object       : typedef = double
	+string_object     : typedef = std::string
	+name_object       : typedef = std::string
	+array_object      : typedef = vector<any_direct_object_or_ref>
	+dictionary_object : typedef = unordered_map<name_object, non_null_direct_object_or_ref>
}
class stream_object {
	-m_stream_dictionary : dictionary_object
	-m_encoded_data      : std::string
	-m_decoded_data      : std::string

	+stream_object<DictionaryT = dictionary_object, DataT = std::string>(in stream_dictionary : DictionaryT&&, in encoded_data : DataT&&)

	+get_decoded_data() : std::string
}
stream_object --> dictionary_object

class null_object<<struct>>  {}

class indirect_reference<<struct>> {
	+object_number : object_t
	+generation_number : generation_t
}
}
@enduml
