@startuml parser
namespace pdfparser {
enum require_type <<Enumeration>> {
	<<Const>>
	+{static} EOF : int = 0
	+{static} EOL : int = 1
	+{static} startxref : int = 2
	+{static} xref : int = 3
	+{static} space : int = 4
}
enum ignore_flag <<Enumeration>> {
	<<Const, Flag>>
	+{static} null : int = 1
	+{static} horizontal_tab : int = 2
	+{static} line_feed : int = 4
	+{static} form_feed : int = 8
	+{static} carriage_return : int = 16
	+{static} space : int = 32
	+{static} comment : int = 64
	+{static} EOL : int = line_feed | carriage_return
	+{static} any_whitespace_characters : int = null | horizontal_tab | line_feed | form_feed | carriage_return | space | EOL
	+{static} any_whitespace_characters_except_EOL : int = any_whitespace_characters & ~EOL
}
class ignore_flag_bitset_t {
	<<Const>>
	+{static} ignore_flag_bitset_t : typedef = std::bitset<7>
}
ignore_flag_bitset_t .. ignore_flag

class parser {
	-m_stream : std::ifstream
	-m_footer : std::unique_ptr<footer>

	+parser<FilenameT>(in filename : const FilenameT&)
	+get_xref_table() : const xref_table&
}
parser "1..*" x--> "1" footer

class footer {
	+xref_byte_offset : std::streamoff
	+xref_table : xref_table

	+footer(inout istr : std::istream&)
}
footer x..> syntax_error
footer x..> parser_utility
footer "1" x--> "1" xref_table

class parser_utility <<utility>> {
	+enum require_type
	+enum ignore_flag

	+{static} seek_to_frontward_beginning_of_line(inout istr : std::istream&) : void
	+{static} take_xref_byte_offset(inout istr : std::istream&) : std::streamoff
	+{static} take_xref_table(inout istr : std::istream&) : xref_table
	+{static} take_xref_entry(inout istr : std::istream&) : xref_entry
	+{static} require(inout istr : std::istream&, in req_type : require_type) : void
	+{static} ignore_if_present(inout istr : std::istream&, in flags : const ignore_flag_bitset_t&) : void
	+{static} take_signed_integer<SignedIntType>(inout istr : std::istream&) : SignedIntType
	+{static} take_unsigned_integer<UnsignedIntType>(inout istr : std::istream&) : UnsignedIntType
}
parser_utility x..> require_type
parser_utility x..> ignore_flag_bitset_t
parser_utility x..> syntax_error
parser_utility x..> overflow_or_underflow_error
parser_utility x..> xref_table
parser_utility x..> xref_entry
parser_utility x..> xref_types

enum error_code <<Enumeration>> {
	<<Const>>
	+{static} EOF_not_found : int = 0
	+{static} EOF_invalid : int = 1
	+{static} EOL_not_found : int = 2
	+{static} xref_byte_offset_not_found : int = 3
	+{static} keyword_startxref_not_found : int = 4
	+{static} signed_integer_not_found : int = 5
	+{static} unsigned_integer_not_found : int = 6
	+{static} keyword_xref_not_found : int = 7
	+{static} space_not_found : int = 8
	+{static} xref_entry_first_10_digits_invalid : int = 9
	+{static} xref_entry_second_5_digits_invalid : int = 10
	+{static} xref_entry_keyword_invalid : int = 11
	+{static} xref_entry_last_2_bytes_invalid : int = 12
}
class syntax_error {
	+enum error_code
	-m_error_code : error_code {Const}

	+syntax_error(in er_code : error_code)
	+code() : error_code
}
syntax_error --|> std::runtime_error
syntax_error x--> "1" error_code

class overflow_or_underflow_error {
	<<Const>>
	+{static} overflow_or_underflow_error : typedef = std::variant<std::overflow_error, std::underflow_error>
}

class xref_types {
	<<Const>>
	+{static} object_t : typedef = uint32_t
	+{static} generation_t : typedef = uint16_t
	+class object_traits
	+class xref_inuse_entry
	+class xref_free_entry
	+{static} xref_entry : typedef = std::variant<xref_inuse_entry, xref_free_entry>
	+{static} xref_table : typedef = std::set<xref_entry>
}
xref_table "1" x--* "1..*" xref_entry
xref_entry "1" x--> "0, 1" xref_inuse_entry
note right on link
xref_inuse_entry XOR xref_free_entry
end note
xref_entry "1" x--> "0, 1" xref_free_entry

abstract class object_traits {
	+object_number : object_t
	+generation_number : generation_t

	#object_traits(in object_number : object_t, in generation_number : generation_t)
	+operator==(in rhs : const object_traits&) : bool
	+operator!=(in rhs : const object_traits&) : bool
	+operator<(in rhs : const object_traits&) : bool
	+operator>(in rhs : const object_traits&) : bool
	+operator<=(in rhs : const object_traits&) : bool
	+operator>=(in rhs : const object_traits&) : bool
}

class xref_inuse_entry {
	+xref_inuse_entry(in object_number : object_t, in generation_number : generation_t, in byte_offset : std::streamoff)
	+byte_offset : std::streamoff
}
xref_inuse_entry ..|> object_traits

class xref_free_entry {
	+xref_free_entry(in object_number : object_t, in generation_number : generation_t, in next_free_object_number : object_t)
	+next_free_object_number : object_t
}
xref_free_entry ..|> object_traits
}
@enduml
