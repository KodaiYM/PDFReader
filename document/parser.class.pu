@startuml parser
namespace pdfparser {
class parser {
	-m_stream : std::ifstream
	-m_footer : std::unique_ptr<footer>

	+parser<FilenameT>(in filename : const FilenameT&)
	+get_xref_table() : const xref_table&
}
parser "1..*" x--> "1" footer

class footer {
	+xref_byte_offset : std::streamoff
	+xref_table : xref_table

	+footer(inout istr : std::istream&)
}
footer x..> syntax_error
footer x..> parser_utility
footer "1" x--> "1" xref_table

enum require_type <<Enumeration>> {
	<<Const>>
	+{static} keyword_EOF : int = 0
	+{static} EOL : int = 1
	+{static} keyword_startxref : int = 2
	+{static} keyword_xref : int = 3
	+{static} space : int = 4
}
enum ignore_flag <<Enumeration>> {
	<<Const, Flag>>
	+{static} none : uint8_t = 0
	+{static} null : uint8_t = 1
	+{static} horizontal_tab : uint8_t = 2
	+{static} line_feed : uint8_t = 4
	+{static} form_feed : uint8_t = 8
	+{static} carriage_return : uint8_t = 16
	+{static} space : uint8_t = 32
	+{static} comment : uint8_t = 64
	+{static} EOL : uint8_t = line_feed | carriage_return
	+{static} any_whitespace_characters : uint8_t = null | horizontal_tab | line_feed | form_feed | carriage_return | space | EOL
	+{static} any_whitespace_characters_except_EOL : uint8_t = any_whitespace_characters & ~EOL
}
class parser_utility <<utility>> {
	enum require_type
	enum ignore_flag
	seek_forward_head_of_line(inout istr : std::istream&) : void
	take_xref_byte_offset(inout istr : std::istream&) : std::streamoff
	take_xref_table(inout istr : std::istream&) : xref_table
	take_xref_entry(inout istr : std::istream&, in object_number : object_t) : xref_entry
	require(inout istr : std::istream&, in req_type : require_type) : void
	ignore_if_present(inout istr : std::istream&, in flags : ignore_flag) : void
	take_signed_integer<IntType>(inout istr : std::istream&) : IntType
	take_unsigned_integer<IntType>(inout istr : std::istream&) : IntType
}
note left: file scope unnamed namespace
parser_utility x..> require_type
parser_utility x..> ignore_flag
parser_utility x..> syntax_error
parser_utility x..> overflow_or_underflow_error
parser_utility x..> xref_table
parser_utility x..> xref_entry
parser_utility x..> xref_types

enum error_code <<Enumeration>> {
	<<Const>>
	+{static} keyword_EOF_not_found : int = 0
	+{static} EOL_not_found : int = 1
	+{static} xref_byte_offset_not_found : int = 2
	+{static} keyword_startxref_not_found : int = 3
	+{static} signed_integer_not_found : int = 4
	+{static} unsigned_integer_not_found : int = 5
	+{static} keyword_xref_not_found : int = 6
	+{static} space_not_found : int = 7
	+{static} xref_entry_first_10_digits_invalid : int = 8
	+{static} xref_entry_second_5_digits_invalid : int = 9
	+{static} xref_entry_keyword_invalid : int = 10
	+{static} xref_entry_last_2_bytes_invalid : int = 11
}
class syntax_error {
	+enum error_code
	-m_error_code : const error_code

	+syntax_error(in er_code : error_code)
	+code() : error_code
}
syntax_error --|> std::runtime_error
syntax_error x--> "1" error_code

class overflow_or_underflow_error {
	+overflow_or_underflow_error()
}
overflow_or_underflow_error --|> std::runtime_error

class xref_types {
	<<Const>>
	+{static} object_t : typedef = uint32_t
	+{static} generation_t : typedef = uint16_t
	+class xref_inuse_entry
	+class xref_free_entry
	+{static} xref_entry : typedef = std::variant<xref_inuse_entry, xref_free_entry>
	+class xref_table_iterator
	+class xref_table_const_iterator
	+class xref_table
}
note left: namespace

xref_entry "1" x--> "0, 1" xref_inuse_entry
note right on link
xref_inuse_entry XOR xref_free_entry
end note
xref_entry "1" x--> "0, 1" xref_free_entry

class xref_inuse_entry {
	+object_number : object_t
	+generation_number : generation_t
	+byte_offset : std::streamoff
	
	+operator==(in rhs : const xref_inuse_entry&) : bool
	+operator!=(in rhs : const xref_inuse_entry&) : bool
}

class xref_free_entry {
	+object_number : object_t
	+next_used_generation_number : generation_t
	+next_free_object_number : object_t
	
	+operator==(in rhs : const xref_free_entry&) : bool
	+operator!=(in rhs : const xref_free_entry&) : bool
}

class xref_table {
	+{static} key_type : typedef = object_t
	+{static} value_type : typedef = xref_entry
	+{static} reference : typedef = value_type&
	+{static} const_reference : typedef = const reference
	+{static} size_type : typedef = std::size_t
	+{static} difference_type : typedef = std::ptrdiff_t
	+{static} iterator : typedef = xref_table_iterator
	+{static} const_iterator : typedef = xref_table_const_iterator
	+{static} reverse_iterator : typedef = std::reverse_iterator<iterator>
	+{static} const_reverse_iterator : typedef = std::reverse_iterator<const_iterator>

	-{static} table_type : typedef = std::map<key_type, value_type>
	-m_table : table_type

	+xref_table()
	+xref_table(in entry_list : initializer_list<value_type>)

	+begin() : iterator
	+cbegin() : const_iterator
	+end() : iterator
	+cend() : const_iterator
	+rbegin() : reverse_iterator
	+crbegin() : const_reverse_iterator
	+rend() : reverse_iterator
	+crend() : const_reverse_iterator

	+insert(in insert_entry : const value_type&) : void
	+insert(in insert_entry : value_type&&) : void
	+erase(in erase_position : const_iterator) : iterator
	+erase(in erase_entry : const value_type&) : iterator
	+erase(in erase_object_number : object_t) : iterator

	+at(in n : key_type) : const_reference

	+operator==(in rhs : const xref_table&) : bool
	+operator!=(in rhs : const xref_table&) : bool
}
xref_table "1" x--* "1..*" xref_entry
xref_table <..> xref_table_iterator
xref_table <..> xref_table_const_iterator

class xref_table_iterator {
	+operator++() : xref_table_iterator&
	+operator++(int) : xref_table_iterator
	+operator--() : xref_table_iterator&
	+operator--(int) : xref_table_iterator
	+operator==(in rhs : const xref_table_iterator&) : bool
	+operator!=(in rhs : const xref_table_iterator&) : bool

	+xref_table_iterator(in table_it : xref_table::table_type::iterator)
}
xref_table_iterator --|> xref_table_const_iterator

class xref_table_const_iterator {
	+{static} iterator_category : typedef = bidirectional_iterator_tag
	+{static} value_type : typedef = xref_entry
	+{static} difference_type : typedef = ptrdiff_t
	+{static} pointer : typedef = const value_type*
	+{static} reference : typedef = const value_type&

	-m_table_it : xref_table::table_type::const_iterator

	+operator*() : reference
	+operator++() : xref_table_const_iterator&
	+operator++(int) : xref_table_const_iterator
	+operator--() : xref_table_const_iterator&
	+operator--(int) : xref_table_const_iterator
	+operator==(rhs : const xref_table_const_iterator&) : bool
	+operator!=(rhs : const xref_table_const_iterator&) : bool

	+xref_table_const_iterator(in table_it : xref_table::table_type::const_iterator)
}
}
@enduml
