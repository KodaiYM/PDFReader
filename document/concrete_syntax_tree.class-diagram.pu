@startuml class
namespace pdfparser::concrete_syntax_tree {
class root {
	+m_components : std::list<std::variant<white_space_characters, comment, regular_characters, literal_string, hexadecimal_string, name, array, dictionary, stream, indirect_object, indirect_reference>>
}

interface has_position {
	+m_position : size_t
}
abstract atom {
	+m_string : std::string

	+atom(size_t position, const std::string& string)
	+operator const std::string&()
}
atom --|> has_position

class white_space_characters
white_space_characters --|> atom

class regular_characters
regular_characters --|> atom

class delimiter_character
delimiter_character --|> atom

class eol {
	+m_content : white_space_characters
	+m_type : type

	+operator type()
}
eol --|> has_position
enum eol::type {
	cr
	lf
	crlf
}

class comment {
	+m_percent_sign = "%" : const delimiter_character
	+m_content : std::string
}
comment --|> has_position

abstract string {
	+m_left_bracket : const delimiter_character
	+m_right_bracket : const delimiter_character
	+m_content : std::string

	+literal_string(size_t position, const std::string& left_bracket, const std::string& right_bracket, const std::string& content)
	+operator const std::string&()
}
string --|> has_position

class literal_string {
	+literal_string(size_t position, const std::string& content)
}
literal_string --|> string

class hexadecimal_string {
	+hexadecimal_string(size_t position, const std::string& content)
}
hexadecimal_string --|> string

class name {
	+m_solidus = "/" : const delimiter_character
	+m_content : regular_characters

	+name(size_t position, const regular_characters& content)
	+operator const std::string&()
}
name --|> has_position

class array {
	+m_left_bracket = "[" : const delimiter_character
	+m_right_bracket = "]" : const delimiter_character
	+m_contents : std::list<std::variant<white_space_characters, comment, regular_characters, literal_string, hexadecimal_string, name, array, dictionary, stream, indirect_reference>>
}
array --|> has_position

class dictionary {
	+m_left_bracket = "<<" : const delimiter_character
	+m_right_bracket = ">>" : const delimiter_character
	+m_contents : std::list<std::variant<white_space_characters, comment, regular_characters, literal_string, hexadecimal_string, name, array, dictionary, stream, indirect_reference>>
}
dictionary --|> has_position

class stream {
	+m_dictionary : dictionary
	+m_white_spaces_after_dictionary : std::optional<std::list<std::variant<white_space_characters, comment>>>
	+m_keyword_stream = "stream" : const regular_characters
	+m_eol_after_keyword_stream : eol
	+m_content : std::string
	+m_eol_after_content : eol
	+m_keyword_endstream = "endstream" : const regular_characters
}
stream --|> has_position

class indirect_object {
	+m_object_number : regular_characters
	+m_white_spaces_after_object_mumber : std::list<std::variant<white_space_characters, comment>>
	+m_generation_number : regular_characters
	+m_white_spaces_after_generation_number : std::list<std::variant<white_space_characters, comment>>
	+m_keyword_obj = "obj" : const regular_characters
	+m_white_spaces_after_keyword_obj : std::optional<std::list<std::variant<white_spaces_characters, comment>>>
	+m_content : std::variant<regular_characters, literal_string, hexadecimal_string, name, array, dictionary, stream>
	+m_white_spaces_after_content : std::optional<std::list<std::variant<white_space_characters, comment>>>
	+m_keyword_endobj = "endobj" : const regular_characters
}
indirect_object --|> has_position

class indirect_reference {
	+m_object_number : regular_characters
	+m_white_spaces_after_object_mumber : std::list<std::variant<white_space_characters, comment>>
	+m_generation_number : regular_characters
	+m_white_spaces_after_generation_number : std::list<std::variant<white_space_characters, comment>>
	m_keyword_R = "R" : const regular_characters
}
indirect_reference --|> has_position
}
@enduml
