@startuml parser
partition "parser(inout istr : std::istream&&)" {
start
	:m_stream = istr;
	:take_footer();
stop
}
@enduml

@startuml get_xref_table
partition "get_xref_table()" {
start
	:return m_xref_table;
stop
}
@enduml

@startuml take_footer
partition "take_footer()" {
start
	:ストリームを最終行の行頭に移動;
	:require(m_stream, EOF);
	:ストリームを最終行の1行前の行頭に移動;
	if (移動できなかった) then (y)
		:throw syntax_error(xref_byte_offset_not_found);
		stop
	endif
	:m_xref_byte_offset = take_xref_byte_offset(m_stream);
	:ストリームを最終行の2行前の行頭に移動;
	if (移動できなかった) then (y)
		:throw syntax_error(keyword_startxref_not_found);
		stop
	endif
	:require(m_stream, startxref);

	:ストリームを先頭から m_xref_byte_offset バイト目に移動;
	:take_xref_table(m_stream);
stop
}
@enduml

@startuml take_xref_byte_offset
partition "take_xref_byte_offset(inout istr : std::istream&)" {
start
	:ignore_if_present(any_whitespace_characters_except_EOL);
	:xref_byte_offset = take_unsigned_integer<decltype(istr.tellg())>();
	if (unsigned_integer_not_found の例外が出た) then (y)
		:throw xref_byte_offset_not_found();
		stop
	endif
	:ignore_if_present(any_whitespace_characters_except_EOL | comment);
	:require(EOL);
	:return xref_byte_offset;
stop
}
@enduml

@startuml take_xref_table
partition "take_xref_table(inout istr : std::istream&)" {
start
	:this_xref_table : xref_table;
	:require(istr, xref);
	:first_object_number = take_unsigned_integer<xref_entry::object_t>() : xref_entry::object_t;
	:require(istr, space);
	:number_of_entries = take_unsigned_integer<uintmax_t> : uintmax_t;
	:ignore_if_present(any_whitespace_characters_except_EOL | comment);
	:require(istr, EOL);
	:entry_offset = 0 : uintmax_t;
	while (entry_offset < number_of_entries)
		:this_xref_table.insert(take_xref_entry(istr, first_object_number + entry_offset));
		:++number_of_entries;
	endwhile
	:return this_xref_table;
stop
}
@enduml

@startuml take_xref_entry
partition "take_xref_entry(inout istr : std::istream&, in object_number : object_t)" {
start
	:first_10_digits = 10バイト取得 : std::string;
	if (first_10_digitsが0-9以外の文字を含む) then (y)
		:throw syntax_error(xref_entry_first_10_digits_invalid);
		stop
	endif
	:require(istr, space);
	:second_5_digits = 5バイト取得 : std::string;
	if (second_5_digitsが0-9以外の文字を含む) then (y)
		:throw syntax_error(xref_entry_second_5_digits_invalid);
		stop
	endif
	:require(istr, space);
	:keyword = 1バイト取得 : char;
	if (keyword != 'n' && keyword != 'f') then (y)
		:throw syntax_error(xref_entry_keyword_invalid);
		stop
	endif
	:last_2_bytes = 2バイト取得 : std::string;
	if (last_2_bytes != space CR && last_2_bytes != space LF && last_2_bytes != CR LF) then (y)
		:throw syntax_error(xref_entry_last_2_bytes_invalid);
		stop
	endif

	:generation_number = second_5_digitsを整数に変換;
	if (generation_number < generation_tの最小値 || generation_tの最大値 < generation_number) then (y)
		:throw overflow_or_underflow_error();
		stop
	endif
	if (keyword == 'n') then (y)
		:this_xref_entry : xref_entry = xref_inuse_entry{object_number, generation_number};
		:byte_offset = first_10_digitsを整数に変換;
		if (byte_offset < this_xref_entry.byte_offsetの最小値 || this_xref_entry.byte_offsetの最大値 < byte_offset) then (y)
			:throw overflow_or_underflow_error();
			stop
		endif
		:this_xref_entry.byte_offset = byte_offset;
	else
		:this_xref_entry : xref_entry = xref_free_entry{object_number, generation_number};
		:next_free_object_number = first_10_digitsを整数に変換;
		if (next_free_object_number < object_tの最小値 || object_tの最小値の最大値 < next_free_object_number) then (y)
			:throw overflow_or_underflow_error();
			stop
		endif
		:this_xref_entry.next_free_object_number = next_free_object_number;
	endif
	:return this_xref_entry;
stop
}
@enduml

@startuml require
partition "require(inout istr : std::istream&, in req_type : require_type)" {
start
	switch (req_type?)
	case (EOF)
		if (ストリームから "%%EOF" が読み取れなかった) then (y)
			:throw syntax_error(EOF_not_found);
			stop
		endif

		if (ファイル終端) then (y)
			stop
		endif

		if (次の文字が "**[EOL]**") then (y)
			stop
		endif

		:throw syntax_error(EOF_invalid);
		stop
	case (EOL)
		if (LF || CRLF || CR) then (y)
			stop
		endif

		:throw syntax_error(EOL_not_found);
		stop
	case (startxref)
		:ignore_if_present(any_whitespace_characters_except_EOL);
		if (ストリームから "startxref" が読み取れなかった) then (y)
			:throw syntax_error(keyword_startxref_not_found);
			stop
		endif
		:ignore_if_present(any_whitespace_characters_except_EOL | comment);
		:require(EOL);
		stop
	case (xref)
		:ignore_if_present(any_whitespace_characters_except_EOL);
		if (ストリームから "xref" が読み取れなかった) then (y)
			:throw syntax_error(keyword_xref_not_found);
			stop
		endif
		:ignore_if_present(any_whitespace_characters_except_EOL | comment);
		:require(EOL);
		stop
	case (space)
		if (ストリームから " " が読み取れなかった) then (y)
			:throw syntax_error(space_not_found);
			stop
		endif
		stop
	endswitch
stop
}
@enduml

@startuml ignore
partition "ignore(inout istr : std::istream&, flags : const std::bitset<7>&)" {
start
	:flagsに指定のある空白類のみ読み飛ばす;
stop
}
@enduml

@startuml take_signed_integer
partition "take_signed_integer<SignedIntType>(inout istr : std::istream&)" {
start
	:+ or - の符号付(あるいは無し)整数の取得;
	if (取得できなかった) then (y)
		:throw syntax_error(signed_integer_not_found);
		stop
	endif
	if (その整数 < SignedIntType の最小値 || SignedIntType の最大値 < その整数) then (y)
		:throw overflow_or_underflow_error();
		stop
	endif
	:return その整数;
stop
}
@enduml

@startuml take_unsigned_integer
partition "take_unsigned_integer<UnsignedIntType>(inout istr : std::istream&)" {
start
	:符号のない整数の取得;
	if (取得できなかった) then (y)
		:throw syntax_error(unsigned_integer_not_found);
		stop
	endif
	if (UnsignedIntType の最大値 < その整数) then (y)
		:throw overflow_or_underflow_error();
		stop
	endif
	:return その整数;
stop
}
@enduml
