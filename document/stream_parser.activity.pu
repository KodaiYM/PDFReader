@startuml stream_parser
partition "stream_parser(in stream : InputStreamT&&)" {
start
	:m_tokenizer = tokenizer(stream);
stop
}
@enduml

@startuml take_footer
partition "take_footer(inout object_accessor : object_pool<InputStreamT>&)" {
start
	:seek_to_end();
	:seek_forward_head_of_line();
	:seek_forward_head_of_line();
	:seek_forward_head_of_line();

	' startxref
	:promise_token("startxref");

	' xref バイトオフセット
	:xref_byte_offset = take_integer_object() : std::streamoff;

	' %%EOF
	:m_tokenizer.promise({"\r\n", "\n", "\r"});
	:m_tokenizer.promise("%%EOF");

	' Cross Reference Table
	:m_tknizer.seek(xref_byte_offset);
	:xref_table = take_xref_table();

	' Trailer
	:object_accessor.add_xref_table(xref_table);
	:return take_trailer(object_accessor);
stop
}
@enduml

@startuml take_xref_table
partition "take_xref_table()" {
start
	:this_xref_table : xref_table;
	:promise_token("xref");

	:first_object_number = take_integer_object() : object_t;
	:number_of_entries = take_integer_object() : object_t;

	if (first_object_number + number_of_entries - 1 がオーバーフロー) then (y)
		:throw std::overflow_error("overflow");
		stop
	endif

	:entry_offset = 0 : object_t;
	while (entry_offset < number_of_entries)
		:this_xref_table.insert(take_xref_entry(first_object_number + entry_offset));
		:++number_of_entries;
	endwhile
	:return this_xref_table;
stop
}
@enduml

@startuml take_xref_entry
partition "take_xref_entry(in object_number : object_t)" {
start
	:first_integer = take_integer_object();
	:second_integer = take_integer_object() : generation_t;

	:keyword = take_token();

	if ("n" == keyword) then (y)
		:byte_offset = first_10_digitsを decltype(this_xref_entry.byte_offset) 型の整数に変換;
		:return xref_inuse_entry{object_number, generation_number, byte_offset};
	elseif ("f" == keyword)
		:next_free_object_number = first_10_digitsを object_t 型の整数に変換;
		:return xref_free_entry{object_number, generation_number, next_free_object_number};
	else
		:throw parse_error(xref_entry_keyword_invalid);
		stop
	endif
stop
}
@enduml

@startuml take_trailer
partition "take_trailer(inout object_accessor : object_pool<InputStreamT>&)" {
start
	:promise_token("trailer");

	:trailer_dictionary = take_dictionary_object();
	:return trailer_dictionary;
stop
}
@enduml

@startuml take_object
partition "take_object<...ObjectTypes>([inout object_accessor : object_pool<InputStreamT>&])" {
start
	if ((constexpr) ObjectTypes に boolean_object がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_boolean_object();
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に real_object がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_real_object();
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に string_object がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_string_object();
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に name_object がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_name_object();
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に array_object がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_array_object();
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に null_object がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_null_object();
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に stream_object がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_stream_object(object_accessor);
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に indirect_reference がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_indirect_reference();
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に integer_object がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_integer_object();
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に dictionary_object がある場合) then (y)
		:before_take_object_pos = m_tknizer.tell();
		:return take_dictionary_object();
		if (object_not_found_error が出た) then (y)
			:m_tknizer.seek(before_take_object_pos);
		endif
	endif

	if ((constexpr) ObjectTypes にその他の型がある場合) then (y)
		:コンパイルエラー;
		stop
	endif

	:throw object_not_found_error(any_object_not_found);
stop
}
@enduml

@startuml take_boolean_object
partition "take_boolean_object()" {
start
	if (attempt_token("true")) then (y)
		:return boolean_object(true);
		stop
	elseif (attempt_token("false")) then (y)
		:return boolean_object(false);
		stop
	endif

	:throw object_not_found_error(boolean_object_not_found);
stop
}
@enduml

@startuml take_integer_object
partition "take_integer_object()" {
start
	:front_token = take_token();

	if (front_token が [+-]10進整数 の形) then (y)
		:first_integer = front_token を解釈した整数;
		:return first_integer;
	endif

	:throw object_not_found_error(integer_object_not_found);
stop
}
@enduml

@startuml take_real_object
partition "take_real_object()" {
start
	:front_token = take_token();

	if (front_token が [+-]10進整数.10進整数 の形（但し、10進整数のどちらかは空でも良い）) then (y)
		:return real_object(front_token を解釈した小数);
		stop
	endif

	:throw object_not_found_error(real_object_not_found);
stop
}
@enduml

@startuml take_string_object
partition "take_string_object()" {
start
	' Literal String
	if (attempt_token("(")) then (y)
		:literal_string : string_object;
		:number_of_left_parenthesis = 1;
		:number_of_right_parenthesis = 0;
		while (!ファイル終端 && number_of_left_parenthesis != number_of_right_parenthesis) is (y)
			switch (次の文字?)
			case (()
				:++number_of_left_parenthesis;
				:literal_string += '(';
			case ())
				:++number_of_right_parenthesis;
				if (number_of_left_parenthesis != number_of_right_parenthesis) then (y)
					:literal_string += ')';
				endif
			case (\\ r)
				:literal_string += '\\n';
				:attempt("\\n");
			case (\\  \\) /' for visibility. just means \\\\ '/
				switch (次の文字?)
				case (n)
					:literal_string += '\\n';
				case (r)
					:literal_string += '\\r';
				case (t)
					:literal_string += '\\ t';
				case (b)
					:literal_string += '\\b';
				case (f)
					:literal_string += '\\f';
				case (()
					:literal_string += '(';
				case ())
					:literal_string += ')';
				case (\\  \\) /' for visibility. just means \\\\ '/
					:literal_string += '\\\\';
				case (\\ r)
					:attempt("\\n");
				case (\\ n)
					:do nothing;
				case (0-7)
					:octal_character = 読み取ったcaseの数値 : uint8_t;
					if (次の文字 == 0-7)
						:octal_character = 8 * octal_character + 読み取ったifの数値;
						if (次の文字 == 0-7)
							:octal_character = 8 * octal_character + 読み取ったifの数値;
						endif
					endif
				case (default)
					:literal_string += 読み取った文字;
				endswitch
			case (default)
				:literal_string += 読み取った文字;
			endswitch
		endwhile

		if (number_of_left_parenthesis != number_of_right_parenthesis) then (y)
			:throw parse_error(literal_string_lack_of_right_parenthesis);
			stop
		endif

		:return string_object(literal_string);
		stop
	endif
	' Hexadecimal String
	if (attempt_token("<")) then (y)
		:hexadecimal_string : string_object;

		:character     : unsigned char = 0;
		:hex_digit_pos : int           = 0;
		while ((hex_token = m_tokenizer.take_token()) != ">") is (y)
			if (!hex_token.has_value()) then (y)
				:throw parse_error(hexadecimal_string_lack_of_greater_than_sign);
				stop
			endif

			:hex_view = hex_token : string_view;
			while (!hex_view.empty()) is (y)
				:++hex_digit_pos;

				:hex_digit = hex_view.front();
				:hex_view.remove_prefix(1);
				if (hex_digit != 0-9, A-F, a-f) then (y)
					:throw parse_error(hexadecimal_string_non_hexadecimal_digit_found);
					stop
				endif

				:character の (hex_digit_pos - 1) * 4 ビット目から4ビット分を hex_digit で埋める;

				if (2 == hex_digit_pos) then (y)
					:hexadecimal_string.push_back(character);
					:character = 0;
					:hex_digit_pos = 0;
				endif
			endwhile
		endwhile
		if (1 == hex_digit_pos) then (y)
			:hexadecimal_string.push_back(character);
		endif

		:return hexadecimal_string;
		stop
	endif

	:throw object_not_found_error(string_object_not_found);
stop
}
@enduml

@startuml take_name_object
partition "take_name_object()" {
start
	if (attempt_token("/")) then (y)
		if (!is_regular(m_tokenizer.peek())) then (y)
			:return name_object();
			stop
		else
			:name_token = take_token();
			:#xx で xx が16進2桁になっている時、その数値の表す文字に置き換える;
			:return name_object(name_token);
			stop
		endif
	endif

	:throw object_not_found_error(name_object_not_found);
stop
}
@enduml

@startuml take_array_object
partition "take_array_object()" {
start
	if (attempt_token("[")) then (y)
		:array : array_object;

		while (!attempt_token("]")) is (y)
			if (no_token()) then (y)
				:throw parse_error(array_lack_of_right_square_bracket);
				stop
			endif

			:element = take_object(object_accessor);
			if (object_not_found_error が出た) then (y)
				:throw parse_error(array_invalid_element);
			endif
			:array.push_back(element);
		endwhile

		:return array;
		stop
	endif

	:throw object_not_found_error(array_object_not_found);
stop
}
@enduml

@startuml take_null_object
partition "take_null_object()" {
start
	if (attempt_token("null")) then (y)
		:return null;
		stop
	endif

	:throw object_not_found_error(null_object_not_found);
stop
}
@enduml

@startuml take_dictionary_object
partition "take_dictionary_object()" {
start
	if (attempt_token("<<")) then (y)
		:dictionary : dictionary_object;

		while (!attempt_token(">>")) is (y)
			if (no_token()) then (y)
				:throw parse_error(dictionary_lack_of_double_greater_than_sign);
				stop
			endif

			:name = take_name_object();
			if (object_not_found_error が出た) then (y)
				:throw parse_error(dictionary_invalid_key);
			endif

			:value = take_object(object_accessor);
			if (object_not_found_error が出た) then (y)
				:throw parse_error(dictionary_invalid_value);
			endif
			if (value != null) then (y)
				:dictionary.emplace(name, value);
			endif
		endwhile

		:return dictionary;
	endif

	:throw object_not_found_error(dictionary_object_not_found);
stop
}
@enduml

@startuml take_stream_object
partition "take_stream_object(inout object_accessor : object_pool<InputStreamT>&)" {
start
	:dictionary = take_dictionary_object();
	if (object_not_found_error が出た) then (y)
		:throw object_not_found_error(stream_object_not_found);
		stop
	endif

	if (!attempt_token("stream")) then (y)
		:throw object_not_found_error(stream_object_not_found);
		stop
	endif

	:m_tokenizer.promise({"\r\n", "\n"});

	if (!dictionary.contains("Length")) then (y)
		:throw parse_error(stream_dictionary_absence_of_Length_entry);
		stop
	endif

	:stream_length = object_accessor.dereference<integer_object>(dictionary.at("Length"));

	:stream_data : std::string = stream_lengthバイト読み取り;
	' HACK: stream_length バイト読み取り中に、Filterに対する明示的なEODマーカーが出現した場合にエラーにする
	if (stream_lengthバイト読み取れなかった) then (y)
		:throw parse_error(stream_data_is_shorter_than_Length);
		stop
	endif

	:m_tokenizer.promise({"\r\n", "\n", "\r"});

	:m_tokenizer.ignore_if_present(EOL);

	:m_tokenizer.promise_token("endstream");
	
	:return stream_object(dictionary, stream_data);
stop
}
@enduml

@startuml take_indirect_reference
partition "take_indirect_reference()" {
start
	:first_integer  = take_integer_object();
	:second_integer = take_integer_object();
	if (object_not_found_error が上のどちらかで出た) then (y)
		:throw object_not_found_error(indirect_reference_not_found);
	endif

	if (attempt_token("R")) then (y)
		:return indirect_reference{first_integer, second_integer};
		stop
	endif

	:throw object_not_found_error(indirect_reference_not_found);
stop
}
@enduml

@startuml take_indirect_object
partition "take_indirect_object(inout object_accessor : object_pool<InputStreamT>&, in object_info : const xref_inuse_entry&)" {
start
	:before_take_indirect_object_pos = m_tknizer.tell();
	:m_tknizer.seek(object_info.byte_offset);

	:first_integer = take_integer_object() : object_t;
	:second_integer = take_integer_object() : generation_t;

	if (first_integer != object_info.object_number || second_integer != object_info.generation_number) then (y)
		:throw parse_error(indirect_object_is_inconsistent_with_xref_table);
		stop
	endif

	:promise_token("obj");

	:object = take_any_direct_object(object_accessor);

	:promise_token("endobj");

	:m_tknizer.seek(before_take_indirect_object_pos);

	:return object;
stop
}
@enduml
