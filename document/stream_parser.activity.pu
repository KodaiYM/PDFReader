@startuml stream_parser
partition "stream_parser(in stream : InputStreamT&&)" {
start
	:m_stream = std::move(stream);
	:m_stream.clear();
	:m_stream.exceptions(std::ios_base::failbit | std::ios_base::badbit);
stop
}
@enduml

@startuml seek_to_end
partition "seek_to_end()" {
start
	' NOTE: undefined behaviour on ISO C but it will go well
	:m_stream.seekg(0, std::ios_base::end);
stop
}
@enduml

@startuml tell
partition "tell()" {
start
	:return m_stream.tellg();
stop
}
@enduml

@startuml seek
partition "seek(in byte_offset_from_beginning_of_file : std::streamoff)" {
start
	:m_stream.seekg(byte_offset_from_beginning_of_file, std::ios_base::beg);
	if (失敗した) then (y)
		:throw parse_error(failed_to_seek);
		stop
	endif
stop
}
@enduml

abc\n
\n
def

@startuml seek_forward_head_of_line
partition "seek_forward_head_of_line()" {
start
	:1バイト戻る;
	if (戻れなかった) then (y)
		:throw parse_error(failed_to_seek_forward_head_of_line);
		stop
	endif
	switch (1バイト先読み?)
	case ('\\r')
		:何もしない;
	case ('\\n')
		:1バイト戻る;
		if (戻れなかった) then (y)
			stop
		endif

		if (1バイト先読み != '\\r') then (y)
			:1バイト進む;
		endif
	endswitch

	repeat
		:1バイト戻る;
		if (戻れなかった) then (y)
			stop
		endif
	repeat while (1バイト先読み != '\\r', '\\n')
	:1バイト進む;
stop
}
@enduml

@startuml take_xref_byte_offset
partition "take_xref_byte_offset()" {
start
	:ignore_if_present(m_stream, any_whitespace_characters_except_EOL);
	:xref_byte_offset = take_unsigned_integer<std::streamoff>();
	if (unsigned_integer_not_found の例外が出た) then (y)
		:throw parse_error(xref_byte_offset_not_found);
		stop
	endif
	:ignore_if_present(m_stream, any_whitespace_characters_except_EOL | comment);
	:require(m_stream, EOL);
	:return xref_byte_offset;
stop
}
@enduml

@startuml take_xref_table
partition "take_xref_table()" {
start
	:this_xref_table : xref_table;
	:require(m_stream, keyword_xref);
	:first_object_number = take_unsigned_integer<object_t>() : object_t;
	:require(m_stream, space);
	:number_of_entries = take_unsigned_integer<object_t> : object_t;
	if (first_object_number + number_of_entries - 1 がオーバーフロー) then (y)
		:throw std::overflow_error("overflow");
		stop
	endif
	:ignore_if_present(m_stream, any_whitespace_characters_except_EOL | comment);
	:require(m_stream, EOL);
	:entry_offset = 0 : object_t;
	while (entry_offset < number_of_entries)
		:this_xref_table.insert(take_xref_entry(m_stream, first_object_number + entry_offset));
		:++number_of_entries;
	endwhile
	:return this_xref_table;
stop
}
@enduml

@startuml take_xref_entry
partition "take_xref_entry(in object_number : object_t)" {
start
	:first_10_digits = 10バイト取得 : std::string;
	if (first_10_digitsが0-9以外の文字を含む) then (y)
		:throw parse_error(xref_entry_first_10_digits_invalid);
		stop
	endif
	:require(m_stream, space);
	:second_5_digits = 5バイト取得 : std::string;
	if (second_5_digitsが0-9以外の文字を含む) then (y)
		:throw parse_error(xref_entry_second_5_digits_invalid);
		stop
	endif
	:require(m_stream, space);
	:keyword = 1バイト取得 : char;
	if (keyword != 'n' && keyword != 'f') then (y)
		:throw parse_error(xref_entry_keyword_invalid);
		stop
	endif
	:last_2_bytes = 2バイト取得 : std::string;
	if (last_2_bytes != space CR && last_2_bytes != space LF && last_2_bytes != CR LF) then (y)
		:throw parse_error(xref_entry_last_2_bytes_invalid);
		stop
	endif

	:generation_number = second_5_digitsを整数に変換;
	if (generation_number < generation_tの最小値 || generation_tの最大値 < generation_number) then (y)
		:throw std::overflow_error("overflow");
		stop
	endif
	if (keyword == 'n') then (y)
		:byte_offset = first_10_digitsを整数に変換;
		if (byte_offset < this_xref_entry.byte_offsetの最小値 || this_xref_entry.byte_offsetの最大値 < byte_offset) then (y)
			:throw std::overflow_error("overflow");
			stop
		endif
		:return xref_inuse_entry{object_number, generation_number, byte_offset};
	else
		:next_free_object_number = first_10_digitsを整数に変換;
		if (next_free_object_number < object_tの最小値 || object_tの最小値の最大値 < next_free_object_number) then (y)
			:throw std::overflow_error("overflow");
			stop
		endif
		:return xref_free_entry{object_number, generation_number, next_free_object_number};
	endif
stop
}
@enduml

@startuml take_trailer
partition "take_trailer(inout object_accessor : object_pool&)" {
start
	:require(m_stream, keyword_trailer);
	:ignore_if_present(m_stream, any_whitespace_characters | comment);
	:trailer_dictionary = take_any_object(m_stream, object_accessor);
	if (trailer_dictionary が dictionary_object じゃない) then (y)
		:throw parse_error(trailer_dictionary_not_found);
		stop
	endif
	:return trailer_dictionary;
stop
}
@enduml

@startuml take_any_object
partition "take_any_object(inout object_accessor : object_pool&)" {
start
	if ("true" が読み取れた) then (y)
		:return boolean_object(true);
		stop
	endif
	if ("false" が読み取れた) then (y)
		:return boolean_object(false);
		stop
	endif

	' Literal String
	if ("(" が読み取れた) then (y)
		:literal_string : string_object;
		:number_of_left_parenthesis = 1;
		:number_of_right_parenthesis = 0;
		while (number_of_left_parenthesis != number_of_right_parenthesis && !ファイル終端) is (y)
			switch (次の文字?)
			case (()
				:++number_of_left_parenthesis;
			case ())
				:++number_of_right_parenthesis;
			case (\\ r)
				:次の文字が '\\n' なら消費する;
				:literal_string += '\\n';
			case (\\  \\) /' for visibility. just means \\\\ '/
				switch (次の文字?)
				case (n)
					:literal_string += '\\n';
				case (r)
					:literal_string += '\\r';
				case (t)
					:literal_string += '\\ t';
				case (b)
					:literal_string += '\\b';
				case (f)
					:literal_string += '\\f';
				case (()
					:literal_string += '(';
				case ())
					:literal_string += ')';
				case (\\  \\) /' for visibility. just means \\\\ '/
					:literal_string += '\\\\';
				case (0-7)
					:octal_character = 読み取ったcaseの数値 : uint8_t;
					if (次の文字 == 0-7)
						:octal_character = 8 * octal_character + 読み取ったifの数値;
						if (次の文字 == 0-7)
							:octal_character = 8 * octal_character + 読み取ったifの数値;
						endif
					endif
				case (\\ r)
					:次の文字が '\\n' なら消費する;
				case (\\ n)
					:do nothing;
				case (default)
					:literal_string += 読み取った文字;
				endswitch
			case (default)
				:literal_string += 読み取った文字;
			endswitch
		endwhile

		if (number_of_left_parenthesis != number_of_right_parenthesis) then (y)
			:throw parse_error(literal_string_lack_of_right_parenthesis);
			stop
		endif

		:return string_object(literal_string);
		stop
	endif

	' Name Object
	if ("/" が読み取れた)
		:name : name_object;
		while (1文字先読み != 空白類文字) is (y)
			if (先読みした文字 == '#') then (y)
				if (次の2文字が16進2桁) then (y)
					:name += 読み取った16進2桁の数値の表す文字;
				else
					:throw parse_error(name_invalid_hexadecimal_code);
					stop
				endif
			else
				:name += 1文字読み取り;
			endif
		endwhile
		:return name;
		stop
	endif

	' Array Object
	if ("[" が読み取れた)
		:array : array_object;

		:ignore_if_present(m_stream, any_whitespace_characters | comment);
		while (!ファイル終端 && 次の文字が ']' じゃない) is (y)
			:array.push_back(take_any_object(m_stream));
			:ignore_if_present(m_stream, any_whitespace_characters | comment);
		endwhile

		' ファイル終端と同義
		if (1文字読み取り != ']') then (y)
			:throw parse_error(array_lack_of_right_square_bracket);
			stop
		endif

		:return array;
		stop
	endif

	' Dictionary Object or Stream Object
	if ("<<" が読み取れた)
		:dictionary : dictionary_object;

		:ignore_if_present(m_stream, any_whitespace_characters | comment);
		while (!ファイル終端 && 次の2文字 != ">>") is (y)
			:name = take_any_object(m_stream);
			if (name が name_object じゃない) then (y)
				:throw parse_error(dictionary_key_is_not_name_object);
			endif
			:ignore_if_present(m_stream, any_whitespace_characters | comment);

			:value = take_any_object(m_stream);
			:ignore_if_present(m_stream, any_whitespace_characters | comment);

			if (value != null) then (y)
				:dictionary.emplace(name, value);
			endif
		endwhile

		' ファイル終端と同義
		if (次の2文字読み取り != ">>") then (y)
			:throw parse_error(dictionary_lack_of_double_greater_than_sign);
			stop
		endif
		:ignore_if_present(m_stream, any_whitespace_characters | comment);

		' Dictionary Object
		if (次の6文字読み取り != "stream") then (y)
			:return dictionary;
			stop
		endif

		' Stream Object
		if (次の1文字 == LF) then (y)
			:do nothing;
		elseif (次の2文字 == CRLF) then (y)
			:do nothing;
		else
			:throw parse_error(stream_CRLF_or_LF_not_found);
			stop
		endif

		if (!dictionary.contains("Length")) then (y)
			:throw parse_error(stream_dictionary_absence_of_Length_entry);
			stop
		endif

		:stream_length = object_accessor.dereference(m_stream, dictionary.at("Length"));
		if (stream_length が integer_object じゃない)
			:throw parse_error(stream_dictionary_absence_of_Length_entry);
			stop
		endif

		:stream_data : std::string = stream_lengthバイト読み取り;
		' HACK: stream_length バイト読み取り中に、Filterに対する明示的なEODマーカーが出現した場合にエラーにする
		if (stream_lengthバイト読み取れなかった) then (y)
			:throw parse_error(stream_data_is_shorter_than_Length);
			stop
		endif
		:require(m_stream, EOL);
		:ignore_if_present(m_stream, EOL);

		if (次の9文字読み取り != "endstream") then (y)
			:throw parse_error(keyword_endstream_not_found);
			stop
		endif
		
		:return stream_object(dictionary, stream_data);
		stop
	endif

	' Hexadecimal String
	if ("<" が読み取れた)
		:hexadecimal_string : string_object;

		:ignore_if_present(m_stream, any_whitespace_characters | comment);
		while (!ファイル終端 && 次の文字 != '>') is (y)
			:character : unsigned char = 0;

			while (2回繰り返し(i : インデックス))
				:hex_digit = 1文字読み取り;
				if (hex_digit == '>') then (y)
					:assert(i != 0);
					:ストリーム位置を1文字分戻す;
					break
				elseif (hex_digit != 0-9, A-F, a-f) then (y)
					:throw parse_error(hexadecimal_string_non_hexadecimal_digit_found);
					stop
				endif

				:character の i * 4 ビット目から4ビット分を hex_digit で埋める;
				:ignore_if_present(m_stream, any_whitespace_characters | comment);
			endwhile

			:hexadecimal_string.push_back(character);
		endwhile

		' ファイル終端と同義
		if (1文字読み取り != '>') then (y)
			:throw parse_error(hexadecimal_string_lack_of_greater_than_sign);
			stop
		endif

		:return hexadecimal_string;
		stop
	endif

	' Null Object
	if ("null" が読み取れた)
		:return null;
		stop
	endif

	' Indirect Reference or Numerical Object
	if (数字が読み取れた)
		' Real Object
		if (小数が読み取れた) then (y)
			:return real_object(読み取った小数);
			stop
		endif

		:first_integer = take_signed_integer<integer_object>(m_stream);
		:ignore_if_present(m_stream, any_whitespace_characters | comment);

		' Integer Object
		if (数字が読み取れなかった) then (y)
			:return integer_object(first_integer);
			stop
		endif

		:second_integer = take_signed_integer<integer_object>(m_stream);
		:ignore_if_present(m_stream, any_whitespace_characters | comment);

		if ("R" が読み取れた) then (y)
			' Indirect Reference
			:return indirect_reference{first_integer, second_integer};
			stop
		endif

		' Integer Object
		:return integer_object(first_integer);
		stop
	endif

	if (ファイル終端) then (y)
		:throw parse_error(object_not_found);
		stop
	endif

	' その他の文字が読み取れた
	:throw parse_error(unknown_character_detected);
stop
}
@enduml

@startuml take_indirect_object
partition "take_indirect_object(inout object_accessor : object_pool&, in object_number : object_t, in generation_number : generation_t)" {
start
	:first_integer = take_signed_integer<object_t>(m_stream);
	:ignore_if_present(m_stream, any_whitespace_characters | comment);
	:second_integer = take_signed_integer<generation_t>(m_stream);
	if (first_integer != object_number || second_integer != generation_number) then (y)
		:throw parse_error(indirect_object_is_inconsistent_with_xref_table);
		stop
	endif

	:ignore_if_present(m_stream, any_whitespace_characters | comment);
	if (3文字読み取り != "obj") then (y)
		:throw parse_error(keyword_obj_not_found);
		stop
	endif

	:ignore_if_present(m_stream, any_whitespace_characters | comment);
	:object = take_any_object(m_stream, object_accessor);
	if (object が indirect_reference) then (y)
		:throw parse_error(indirect_object_refers_indirect_reference);
		stop
	endif

	:ignore_if_present(m_stream, any_whitespace_characters | comment);
	if (6文字読み取り != "endobj") then (y)
		:throw parse_error(keyword_endobj_not_found);
		stop
	endif

	:return object;
stop
}
@enduml


@startuml require
partition "require(in req_type : require_type)" {
start
	switch (req_type?)
	case (keyword_EOF)
		if (ストリームから "%%EOF" が読み取れなかった) then (y)
			:throw parse_error(keyword_EOF_not_found);
			stop
		endif

		if (ファイル終端) then (y)
			stop
		endif

		:require(m_stream, EOL);
	case (EOL)
		if (LF || CRLF || CR) then (y)
			stop
		endif

		:throw parse_error(EOL_not_found);
		stop
	case (keyword_startxref)
		:ignore_if_present(m_stream, any_whitespace_characters_except_EOL);
		if (ストリームから "startxref" が読み取れなかった) then (y)
			:throw parse_error(keyword_startxref_not_found);
			stop
		endif
		:ignore_if_present(m_stream, any_whitespace_characters_except_EOL | comment);
		:require(m_stream, EOL);
	case (keyword_xref)
		:ignore_if_present(m_stream, any_whitespace_characters_except_EOL);
		if (ストリームから "xref" が読み取れなかった) then (y)
			:throw parse_error(keyword_xref_not_found);
			stop
		endif
		:ignore_if_present(m_stream, any_whitespace_characters_except_EOL | comment);
		:require(m_stream, EOL);
	case (space)
		if (ストリームから " " が読み取れなかった) then (y)
			:throw parse_error(space_not_found);
			stop
		endif
	case (keyword_trailer)
		if (ストリームから "trailer" が読み取れなかった) then (y)
			:throw parse_error(keyword_trailer_not_found);
			stop
		endif
	endswitch
stop
}
@enduml

@startuml ignore_if_present
partition "ignore_if_present(flags : ignore_flag)" {
start
	:flagsに指定のある空白類のみ読み飛ばす;
stop
}
@enduml

@startuml take_signed_integer
partition "take_signed_integer<IntType>()" {
start
	:+ or - の符号付(あるいは無し)整数の取得;
	if (取得できなかった) then (y)
		:throw parse_error(signed_integer_not_found);
		stop
	endif
	if (その整数 < IntType の最小値 || IntType の最大値 < その整数) then (y)
		:throw std::overflow_error("overflow");
		stop
	endif
	:return その整数;
stop
}
@enduml

@startuml take_unsigned_integer
partition "take_unsigned_integer<IntType>()" {
start
	:符号のない整数の取得;
	if (取得できなかった) then (y)
		:throw parse_error(unsigned_integer_not_found);
		stop
	endif
	if (IntType の最大値 < その整数) then (y)
		:throw std::overflow_error("overflow");
		stop
	endif
	:return その整数;
stop
}
@enduml
