@startuml stream_parser
partition "stream_parser(in stream : InputStreamT&&)" {
start
	:m_stream = std::move(stream);
	:m_stream.clear();
	:m_stream.exceptions(std::ios_base::failbit | std::ios_base::badbit);
stop
}
@enduml

@startuml take_footer
partition "take_footer(inout object_accessor : object_pool<InputStreamT>&)" {
start
	:seek_to_end();
	:seek_forward_head_of_line();
	:seek_forward_head_of_line();
	:seek_forward_head_of_line();

	' startxref
	if (!take_token("startxref")) then (y)
		:throw parse_error(keyword_startxref_not_found);
		stop
	endif

	' xref バイトオフセット
	:xref_byte_offset = take_object<integer_object>() : std::streamoff;

	' %%EOF
	:string_expected_to_be_EOF : std::string;
	:getline(m_stream, string_expected_to_be_EOF);
	if ("%%EOF" != string_expected_to_be_EOF) then (y)
		:throw parse_error(keyword_EOF_not_found);
		stop
	endif

	' Cross Reference Table
	:seek(xref_byte_offset);
	:xref_table = take_xref_table();

	' Trailer
	:object_accessor.add_xref_table(xref_table);
	:return take_trailer(object_accessor);
stop
}
@enduml

@startuml seek_to_end
partition "seek_to_end()" {
start
	' NOTE: undefined behaviour on ISO C but it will go well on Windows
	:m_stream.seekg(0, std::ios_base::end);
stop
}
@enduml

@startuml eof
partition "eof()" {
start
	if (ファイル終端) then (y)
		:return true;
	else
		:return false;
	endif
stop
}
@enduml

@startuml tell
partition "tell()" {
start
	:return m_stream.tellg();
stop
}
@enduml

@startuml seek
partition "seek(in byte_offset_from_beginning_of_file : std::streamoff)" {
start
	:m_stream.seekg(byte_offset_from_beginning_of_file, std::ios_base::beg);
	if (失敗した) then (y)
		:throw parse_error(failed_to_seek);
		stop
	endif
stop
}
@enduml

@startuml seek_forward_head_of_line
partition "seek_forward_head_of_line()" {
start
	:1バイト戻る;
	if (戻れなかった) then (y)
		:throw parse_error(failed_to_seek_forward_head_of_line);
		stop
	endif
	switch (1バイト先読み?)
	case ('\\r')
		:何もしない;
	case ('\\n')
		:1バイト戻る;
		if (戻れなかった) then (y)
			stop
		endif

		if (1バイト先読み != '\\r') then (y)
			:1バイト進む;
		endif
	endswitch

	repeat
		:1バイト戻る;
		if (戻れなかった) then (y)
			stop
		endif
	repeat while (1バイト先読み != '\\r', '\\n')
	:1バイト進む;
stop
}
@enduml

@startuml take_xref_table
partition "take_xref_table()" {
start
	:this_xref_table : xref_table;
	if (!take_token("xref")) then (y)
		:throw parse_error(keyword_xref_not_found);
		stop
	endif

	:first_object_number = take_object<integer_object>() : object_t;
	:number_of_entries = take_object<integer_object>() : object_t;

	if (first_object_number + number_of_entries - 1 がオーバーフロー) then (y)
		:throw std::overflow_error("overflow");
		stop
	endif

	:entry_offset = 0 : object_t;
	while (entry_offset < number_of_entries)
		:this_xref_table.insert(take_xref_entry(first_object_number + entry_offset));
		:++number_of_entries;
	endwhile
	:return this_xref_table;
stop
}
@enduml

@startuml take_xref_entry
partition "take_xref_entry(in object_number : object_t)" {
start
	:first_integer = take_object<integer_object>();
	:second_integer = take_object<integer_object>() : generation_t;

	:keyword = take_token();

	if ("n" == keyword) then (y)
		:byte_offset = first_10_digitsを decltype(this_xref_entry.byte_offset) 型の整数に変換;
		:return xref_inuse_entry{object_number, generation_number, byte_offset};
	elseif ("f" == keyword)
		:next_free_object_number = first_10_digitsを object_t 型の整数に変換;
		:return xref_free_entry{object_number, generation_number, next_free_object_number};
	else
		:throw parse_error(xref_entry_keyword_invalid);
		stop
	endif
stop
}
@enduml

@startuml take_trailer
partition "take_trailer(inout object_accessor : object_pool&)" {
start
	if (!take_token("trailer")) then (y)
		:throw parse_error(keyword_trailer_not_found);
		stop
	endif

	:trailer_dictionary = take_object<dictionary_object>();
	:return trailer_dictionary;
stop
}
@enduml

@startuml take_object_default
partition "take_object(inout object_accessor : object_pool&)" {
start
	:return take_object<any_direct_object_or_ref の型リスト>(object_accessor);
stop
}
@enduml

@startuml take_object
partition "take_object<...ObjectTypes>(inout object_accessor : object_pool& (ObjectTypes に stream_object がある場合のみ))" {
start
	if ((constexpr) ObjectTypes に boolean_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<boolean_object>();
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に real_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<real_object>();
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に string_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<string_object>();
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に name_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<name_object>();
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に array_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<array_object>();
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に null_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<null_object>();
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に stream_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<stream_object>(object_accessor);
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に indirect_reference がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<indirect_reference>();
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に integer_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<integer_object>();
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に dictionary_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_object<dictionary_object>();
		if (object_not_found_error が出た) then (y)
			seek(before_take_object_pos);
		endif
	endif

	if ((constexpr) ObjectTypes にその他の型がある場合) then (y)
		:コンパイルエラー;
		stop
	endif

	:throw object_not_found_error(any_object_not_found);
stop
}
@enduml

@startuml take_object_boolean
partition "take_object<boolean_object>()" {
start
	:front_token = take_token();

	if (take_token("true")) then (y)
		:return boolean_object(true);
		stop
	elseif (take_token("false")) then (y)
		:return boolean_object(false);
		stop
	endif

	:throw object_not_found_error(boolean_object_not_found);
stop
}
@enduml

@startuml take_object_integer
partition "take_object<integer_object>()" {
start
	:front_token = take_token();

	if (front_token が [+-]10進整数 の形) then (y)
		:first_integer = front_token を解釈した整数;
		:return first_integer;
	endif

	:throw object_not_found_error(integer_object_not_found);
stop
}
@enduml

@startuml take_object_real
partition "take_object<real_object>()" {
start
	:front_token = take_token();

	if (front_token が [+-]10進整数.10進整数 の形（但し、10進整数のどちらかは空でも良い）) then (y)
		:return real_object(front_token を解釈した小数);
		stop
	endif

	:throw object_not_found_error(real_object_not_found);
stop
}
@enduml

@startuml take_object_string
partition "take_object<string_object>()" {
start
	' Literal String
	if (take_token("(")) then (y)
		:literal_string : string_object;
		:number_of_left_parenthesis = 1;
		:number_of_right_parenthesis = 0;
		while (!ファイル終端 && number_of_left_parenthesis != number_of_right_parenthesis) is (y)
			switch (次の文字?)
			case (()
				:++number_of_left_parenthesis;
				:literal_string += '(';
			case ())
				:++number_of_right_parenthesis;
				if (number_of_left_parenthesis != number_of_right_parenthesis) then (y)
					:literal_string += ')';
				endif
			case (\\ r)
				:literal_string += '\\n';
				:attempt("\\n");
			case (\\  \\) /' for visibility. just means \\\\ '/
				switch (次の文字?)
				case (n)
					:literal_string += '\\n';
				case (r)
					:literal_string += '\\r';
				case (t)
					:literal_string += '\\ t';
				case (b)
					:literal_string += '\\b';
				case (f)
					:literal_string += '\\f';
				case (()
					:literal_string += '(';
				case ())
					:literal_string += ')';
				case (\\  \\) /' for visibility. just means \\\\ '/
					:literal_string += '\\\\';
				case (\\ r)
					:attempt("\\n");
				case (\\ n)
					:do nothing;
				case (0-7)
					:octal_character = 読み取ったcaseの数値 : uint8_t;
					if (次の文字 == 0-7)
						:octal_character = 8 * octal_character + 読み取ったifの数値;
						if (次の文字 == 0-7)
							:octal_character = 8 * octal_character + 読み取ったifの数値;
						endif
					endif
				case (default)
					:literal_string += 読み取った文字;
				endswitch
			case (default)
				:literal_string += 読み取った文字;
			endswitch
		endwhile

		if (number_of_left_parenthesis != number_of_right_parenthesis) then (y)
			:throw parse_error(literal_string_lack_of_right_parenthesis);
			stop
		endif

		:return string_object(literal_string);
		stop
	endif
	' Hexadecimal String
	if (take_token("<")) then (y)
		:hexadecimal_string : string_object;

		:character     : unsigned char = 0;
		:hex_digit_pos : int           = 0;
		while (!take_token(">")) is (y)
			if (eof()) then (y)
				:throw parse_error(hexadecimal_string_lack_of_greater_than_sign);
				stop
			endif
			:++hex_digit_pos;

			:hex_digit = 1文字読み取り;
			if (hex_digit != 0-9, A-F, a-f) then (y)
				:throw parse_error(hexadecimal_string_non_hexadecimal_digit_found);
				stop
			endif

			:character の (hex_digit_pos - 1) * 4 ビット目から4ビット分を hex_digit で埋める;

			if (2 == hex_digit_pos) then (y)
				:hexadecimal_string.push_back(character);
				:character = 0;
				:hex_digit_pos = 0;
			endif
		endwhile
		if (1 == hex_digit_pos) then (y)
			:hexadecimal_string.push_back(character);
		endif

		:return hexadecimal_string;
		stop
	endif

	:throw object_not_found_error(string_object_not_found);
stop
}
@enduml

@startuml take_object_name
partition "take_object<name_object>()" {
start
	if (take_token("/")) then (y)
		if (ファイル終端 || 先読みした1文字 != regular 文字) then (y)
			:return name_object();
			stop
		else
			:name_token = take_token();
			:#xx で xx が16進2桁になっている時、その数値の表す文字に置き換える;
			:return name_object(take_token());
			stop
		endif
	endif

	:throw object_not_found_error(name_object_not_found);
stop
}
@enduml

@startuml take_object_array
partition "take_object<array_object>()" {
start
	if (take_token("[")) then (y)
		:array : array_object;

		while (!take_token("]")) is (y)
			if (eof()) then (y)
				:throw parse_error(array_lack_of_right_square_bracket);
				stop
			endif

			:element = take_object(object_accessor);
			if (object_not_found_error が出た) then (y)
				:throw parse_error(array_invalid_element);
			endif
			:array.push_back(element);
		endwhile

		:return array;
		stop
	endif

	:throw object_not_found_error(array_object_not_found);
stop
}
@enduml

@startuml take_object_null
partition "take_object<null_object>()" {
start
	if (take_token("null")) then (y)
		:return null;
		stop
	endif

	:throw object_not_found_error(null_object_not_found);
stop
}
@enduml

@startuml take_object_dictionary
partition "take_object<dictionary_object>()" {
start
	if (take_token("<<")) then (y)
		:dictionary : dictionary_object;

		while (!take_token(">>")) is (y)
			if (eof()) then (y)
				:throw parse_error(dictionary_lack_of_double_greater_than_sign);
				stop
			endif

			:name = take_object<name_object>();
			if (object_not_found_error が出た) then (y)
				:throw parse_error(dictionary_invalid_key);
			endif

			:value = take_object(object_accessor);
			if (object_not_found_error が出た) then (y)
				:throw parse_error(dictionary_invalid_value);
			endif
			if (value != null) then (y)
				:dictionary.emplace(name, value);
			endif
		endwhile

		:return dictionary;
	endif

	:throw object_not_found_error(dictionary_object_not_found);
stop
}
@enduml

@startuml take_object_stream
partition "take_object<stream_object>(inout object_accessor : object_pool<InputStreamT>&)" {
start
	:dictionary = take_object<dictionary_object>();
	if (object_not_found_error が出た) then (y)
		:throw object_not_found_error(stream_object_not_found);
		stop
	endif

	if (!take_token("stream")) then (y)
		:throw object_not_found_error(stream_object_not_found);
		stop
	endif

	if (!(attempt("\r\n") || attempt("\n"))) then (y)
		:throw parse_error(stream_CRLF_or_LF_not_found);
		stop
	endif

	if (!dictionary.contains("Length")) then (y)
		:throw parse_error(stream_dictionary_absence_of_Length_entry);
		stop
	endif

	:stream_length = object_accessor.dereference<integer_object>(dictionary.at("Length"));

	:stream_data : std::string = stream_lengthバイト読み取り;
	' HACK: stream_length バイト読み取り中に、Filterに対する明示的なEODマーカーが出現した場合にエラーにする
	if (stream_lengthバイト読み取れなかった) then (y)
		:throw parse_error(stream_data_is_shorter_than_Length);
		stop
	endif
	if (!(attempt("\r\n") || attempt("\n") || attempt("\r"))) then (y)
		:throw parse_error(EOL_not_found);
		stop
	endif

	:ignore_if_present(EOL);

	if (!take_token("endstream")) then (y)
		:throw parse_error(keyword_endstream_not_found);
		stop
	endif
	
	:return stream_object(dictionary, stream_data);
stop
}
@enduml

@startuml take_object_indirect_reference
partition "take_object<indirect_reference>()" {
start
	:first_integer  = take_object<integer_object>();
	:second_integer = take_object<integer_object>();
	if (object_not_found_error が上のどちらかで出た) then (y)
		:throw object_not_found_error(indirect_reference_not_found);
	endif

	if (take_token("R")) then (y)
		:return indirect_reference{first_integer, second_integer};
		stop
	endif

	:throw object_not_found_error(indirect_reference_not_found);
stop
}
@enduml

@startuml take_indirect_object
partition "take_indirect_object(inout object_accessor : object_pool<InputStreamT>&, in object_info : const xref_inuse_entry&)" {
start
	:before_take_indirect_object_pos = tell();
	:seek(object_info.byte_offset);

	:first_integer = take_object<integer_object>() : object_t;
	:second_integer = take_object<integer_object>() : generation_t;

	if (first_integer != object_info.object_number || second_integer != object_info.generation_number) then (y)
		:throw parse_error(indirect_object_is_inconsistent_with_xref_table);
		stop
	endif

	if (!take_token("obj")) then (y)
		:throw parse_error(keyword_obj_not_found);
		stop
	endif

	:object = take_object<any_direct_object>(object_accessor);

	if (!take_token("endobj")) then (y)
		:throw parse_error(keyword_endobj_not_found);
		stop
	endif

	:seek(before_take_indirect_object_pos);

	:return object;
stop
}
@enduml

@startuml take_token_attempt
partition "take_token(in attempt_token : string_view)" {
start
	:before_take_token_pos = tell();
	if (attempt_token == take_token()) then (y)
		:return true;
		stop
	else
		:seek(before_take_token_pos);
		:return false;
		stop
	endif
end
}
@enduml

@startuml take_token
partition "take_token()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	if (eof()) then (y)
		:return nullopt;
		stop
	endif

	' delimiter token
	if (2文字先読み == "<<", ">>") then (y)
		:ストリームを2文字分進める;
		:return pdftoken(delimiter_token, 先読みした文字列);
		stop
	endif
	' % はあり得ない
	if (1文字先読み == '(', ')', '<', '>', '[', ']', '{', '}', '/') then (y)
		:ストリームを1文字分進める;
		:return pdftoken(delimiter_token, 先読みした文字列);
		stop
	endif

	' regular token
	:regular_characters : std::string;
	while (1文字先読み == レギュラー文字) then (y)
		:ストリームを1文字分進める;
		:regular_characters.push_back(先読みした文字);
	endwhile
	:return pdftoken(regular_token, regular_characters);
stop
}
@enduml

@startuml attempt
partition "attempt(in attempt_str : string_view)" {
start
	if (ストリームから attempt_str が読み取れた) then (y)
		:return true;
	else
		:return false;
	endif
stop
}
@enduml

@startuml ignore_if_present
partition "ignore_if_present(flags : ignore_flag)" {
start
	:flagsに指定のある空白類のみ読み飛ばす;
stop
}
@enduml
