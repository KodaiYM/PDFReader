@startuml take_object
partition "take_object<...ObjectTypes>()" {
start
	:ignore_if_present(any_whitespace_characters | comment);

	if ((constexpr) ObjectTypes に boolean_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_boolean_object();
		if (boolean_object_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に real_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_real_object();
		if (real_object_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に string_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_string_object();
		if (string_object_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に name_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_name_object();
		if (name_object_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に array_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_array_object();
		if (array_object_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に null_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_null_object();
		if (null_object_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に stream_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_stream_object();
		if (stream_object_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に indirect_reference がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_indirect_reference();
		if (indirect_reference_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に integer_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_integer_object();
		if (integer_object_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif
	if ((constexpr) ObjectTypes に dictionary_object がある場合) then (y)
		:before_take_object_pos = tell();
		:return take_dictionary_object();
		if (dictionary_object_not_found が出た) then (y)
			:seek(before_take_object_pos);
		endif
	endif

	if ((constexpr) ObjectTypes にその他の型がある場合) then (y)
		:コンパイルエラー;
		stop
	endif

	:throw specified_object_not_found(tell());
stop
}
@enduml

@startuml take_boolean_object
partition "take_boolean_object()" {
start
	:ignore_if_present(any_whitespace_characters | comment);

	if (attempt_token("true")) then (y)
		:return boolean_object(true);
		stop
	elseif (attempt_token("false")) then (y)
		:return boolean_object(false);
		stop
	endif

	:throw boolean_object_not_found(tell());
stop
}
@enduml

@startuml take_integer_object
partition "take_integer_object()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	:before_take_integer_pos = tell();
	:front_token = take_token();

	if (front_token が [+-]?10進整数 の形) then (y)
		:first_integer = front_token を解釈した整数;
		:return first_integer;
	endif

	:throw integer_object_not_found(before_take_integer_pos);
stop
}
@enduml

@startuml take_real_object
partition "take_real_object()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	:before_take_real_pos = tell();
	:front_token = take_token();

	if (front_token が [+-]?10進整数.10進整数 の形（但し、10進整数のどちらかは空でも良い）) then (y)
		:return real_object(front_token を解釈した小数);
		stop
	endif

	:throw real_object_not_found(before_take_real_pos);
stop
}
@enduml

@startuml take_string_object
partition "take_string_object()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	:before_take_string_pos = tell();

	' Literal String
	if (attempt_token("(")) then (y)
		:literal_string : string_object;
		:number_of_left_parenthesis = 1;
		:number_of_right_parenthesis = 0;
		while (!ファイル終端 && number_of_left_parenthesis != number_of_right_parenthesis) is (y)
			switch (次の文字?)
			case (()
				:++number_of_left_parenthesis;
				:literal_string += '(';
			case ())
				:++number_of_right_parenthesis;
				if (number_of_left_parenthesis != number_of_right_parenthesis) then (y)
					:literal_string += ')';
				endif
			case (\\ r)
				:literal_string += '\\n';
				:attempt("\\n");
			case (\\  \\) /' for visibility. just means \\\\ '/
				switch (次の文字?)
				case (n)
					:literal_string += '\\n';
				case (r)
					:literal_string += '\\r';
				case (t)
					:literal_string += '\\ t';
				case (b)
					:literal_string += '\\b';
				case (f)
					:literal_string += '\\f';
				case (()
					:literal_string += '(';
				case ())
					:literal_string += ')';
				case (\\  \\) /' for visibility. just means \\\\ '/
					:literal_string += '\\\\';
				case (\\ r)
					:attempt("\\n");
				case (\\ n)
					:do nothing;
				case (0-7)
					:octal_character = 読み取ったcaseの数値 : uint8_t;
					if (次の文字 == 0-7)
						:octal_character = 8 * octal_character + 読み取ったifの数値;
						if (次の文字 == 0-7)
							:octal_character = 8 * octal_character + 読み取ったifの数値;
						endif
					endif
				case (default)
					:literal_string += 読み取った文字;
				endswitch
			case (default)
				:literal_string += 読み取った文字;
			endswitch
		endwhile

		if (number_of_left_parenthesis != number_of_right_parenthesis) then (y)
			:throw literal_string_lack_of_right_parenthesis(before_take_string_pos);
			stop
		endif

		:return string_object(literal_string);
		stop
	endif
	' Hexadecimal String
	if (attempt_token("<")) then (y)
		:hexadecimal_string : string_object;

		:character     : unsigned char = 0;
		:hex_digit_pos : int           = 0;
		while ((hex_token = take_token()) != ">") is (y)
			if (!hex_token.has_value()) then (y)
				:throw hexadecimal_string_lack_of_greater_than_sign(before_take_string_pos);
				stop
			endif

			:hex_view = hex_token : string_view;
			while (hex_digit in hex_view) is (y)
				:++hex_digit_pos;

				if (hex_digit != 0-9, A-F, a-f) then (y)
					:throw hexadecimal_string_non_hexadecimal_digit_found(tell() - (hex_view.length() - hex_digitの位置));
					stop
				endif

				:character の (hex_digit_pos - 1) * 4 ビット目から4ビット分を hex_digit で埋める;

				if (2 == hex_digit_pos) then (y)
					:hexadecimal_string.push_back(character);
					:character = 0;
					:hex_digit_pos = 0;
				endif
			endwhile
		endwhile
		if (1 == hex_digit_pos) then (y)
			:hexadecimal_string.push_back(character);
		endif

		:return hexadecimal_string;
		stop
	endif

	:throw string_object_not_found(before_take_string_pos);
stop
}
@enduml

@startuml take_name_object
partition "take_name_object()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	:before_take_name_pos = tell();

	if (attempt_token("/")) then (y)
		if (!is_regular(peek())) then (y)
			:return name_object();
			stop
		else
			:name_token = take_token();
			:#xx で xx が16進2桁になっている時、その数値の表す文字に置き換える;
			:return name_object(name_token);
			stop
		endif
	endif

	:throw name_object_not_found(before_take_name_pos);
stop
}
@enduml

@startuml take_array_object
partition "take_array_object()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	:before_take_array_pos = tell();

	if (attempt_token("[")) then (y)
		:array : array_object;

		while (!attempt_token("]")) is (y)
			if (no_token()) then (y)
				:throw array_lack_of_right_square_bracket(before_take_array_pos);
				stop
			endif

			:ignore_if_present(any_whitespace_characters | comment);
			:before_element_pos = tell();
			:element = take_object();
			if (specified_object_not_found が出た) then (y)
				:throw array_invalid_element(before_element_pos);
			endif
			:array.push_back(element);
		endwhile

		:return array;
		stop
	endif

	:throw array_object_not_found(before_take_array_pos);
stop
}
@enduml

@startuml take_null_object
partition "take_null_object()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	:before_take_null_pos = tell();

	if (attempt_token("null")) then (y)
		:return null;
		stop
	endif

	:throw null_object_not_found(before_take_null_pos);
stop
}
@enduml

@startuml take_dictionary_object
partition "take_dictionary_object()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	:before_take_dictionary_pos = tell();

	if (attempt_token("<<")) then (y)
		:dictionary : dictionary_object;

		while (!attempt_token(">>")) is (y)
			if (no_token()) then (y)
				:throw dictionary_lack_of_double_greater_than_sign(before_take_dictionary_pos);
				stop
			endif

			:name = take_name_object();
			if (name_object_not_found が出た) then (y)
				:throw dictionary_invalid_key(tell());
			endif

			:value = take_object();
			if (specified_object_not_found が出た) then (y)
				:throw dictionary_invalid_value(tell());
			endif
			if (value != null) then (y)
				:dictionary.emplace(name, value);
			endif
		endwhile

		:return dictionary;
	endif

	:throw dictionary_object_not_found(before_take_dictionary_pos);
stop
}
@enduml

@startuml take_stream_object
partition "take_stream_object()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	:before_take_stream_object_pos = tell();

	:dictionary = take_dictionary_object();
	if (dictionary_object_not_found が出た) then (y)
		:throw stream_object_not_found(before_take_stream_object_pos);
		stop
	endif

	if (!attempt_token("stream")) then (y)
		:throw stream_object_not_found(before_take_stream_object_pos);
		stop
	endif

	:promise({"\r\n", "\n"});

	if (!dictionary.contains("Length")) then (y)
		:throw stream_dictionary_absence_of_Length_entry(before_take_stream_object_pos);
		stop
	endif

	:stream_length = dereference<integer_object>(dictionary.at("Length"));

	:head_of_data = tell();
	:stream_data : std::string = stream_lengthバイト読み取り;
	' HACK: stream_length バイト読み取り中に、Filterに対する明示的なEODマーカーが出現した場合にエラーにする
	if (stream_lengthバイト読み取れなかった) then (y)
		:throw stream_data_is_shorter_than_Length(head_of_data);
		stop
	endif

	:promise({"\r\n", "\n", "\r"});

	:ignore_if_present(EOL);

	:promise_token("endstream");
	
	:return stream_object(dictionary, stream_data);
stop
}
@enduml

@startuml take_indirect_reference
partition "take_indirect_reference()" {
start
	:ignore_if_present(any_whitespace_characters | comment);
	:before_take_indirect_reference_pos = tell();

	:first_integer  = take_integer_object();
	:second_integer = take_integer_object();
	if (integer_object_not_found が上のどちらかで出た) then (y)
		:throw indirect_reference_not_found(before_take_indirect_reference_pos);
	endif

	if (attempt_token("R")) then (y)
		:return indirect_reference{first_integer, second_integer};
		stop
	endif

	:throw indirect_reference_not_found(before_take_indirect_reference_pos);
stop
}
@enduml

@startuml take_indirect_object
partition "take_indirect_object(in object_info : const xref_inuse_entry&)" {
start
	:before_take_indirect_object_pos = tell();
	:seek(object_info.byte_offset);

	:ignore_if_present(any_whitespace_characters | comment);
	:begin_of_indirect_object = tell();

	:first_integer = take_integer_object() : object_t;
	:second_integer = take_integer_object() : generation_t;

	if (first_integer != object_info.object_number || second_integer != object_info.generation_number) then (y)
		:indirect_object_is_inconsistent_with_xref_table(begin_of_indirect_object, object_info);
		stop
	endif

	:promise_token("obj");

	:object = take_any_direct_object();

	:promise_token("endobj");

	:seek(before_take_indirect_object_pos);

	:return object;
stop
}
@enduml

@startuml add_xref_table
partition "add_xref_table(in referenced_xref_table : const xref_table&)" {
start
	' HACK: change to add
	:m_xref_table = referenced_xref_table;
stop
}
@enduml

@startuml dereference of any
partition "dereference<...ObjectTypes>(in object : const std::variant<...ObjectTypesContainingRef>&)" {
start
	if (object が indirect_reference) then (y)
		:return dereference<ObjectTypes...>(object as indirect_reference);
		stop
	else
		if (object が ObjectTypes のいずれかの型を持つ) then (y)
			:return object;
			stop
		else
			:throw type_mismatch;
			stop
		endif
	endif
'stop
}
@enduml

@startuml dereference of reference
partition "dereference<...ObjectTypes>(in reference : const indirect_reference&)" {
start
	if (!m_object_cache.contains(pair{reference.object_number, reference.generation_number})) then (y)
		if (m_xref_table.contains(reference.object_number, reference.generation_number) && m_xref_table.at(reference.object_number, reference.generation_number) は xref_inuse_entry) then (y)
			:new_object = take_indirect_object(*this, m_xref_table.at(reference.object_number, reference.generation_number));
		else
			:new_object = null;
		endif

		:m_object_cache.add(pair{reference.object_number, reference.generation_number}, new_object);
	endif

	:object = m_object_cache.get(pair{reference.object_number, reference.generation_number});
	if (object が ObjectTypes のいずれかの型を持つ)
		:return object;
		stop
	else
		:throw type_mismatch;
		stop
	endif
'stop
}
@enduml
